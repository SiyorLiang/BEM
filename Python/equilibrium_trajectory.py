# Calculate the equilibrium trajectory of ions in a Paul trap
# Using SI units
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import MField
MField.MFieldInit(MField.PATH_4ROD, [-0.005,0.005,100], [-0.005,0.005,100],
                  [2.095,2.105,100], '5d49bb9d6704e98ea598bb82a952b646')
N = 5 # number of ions
omega_rf = 2 * np.pi * 25e6
# Doppler cooling. The largest cooling rate is achieved when laser intensity
# ~ I_sat, detuning ~ -Gamma. The friction is F = -alpha * v
# where alpha ~ 8\hbar k^2
# gamma is the fraction of the real time cooling rate in the maximum,
# starting from gamma0 and gradually going to 0.
# We can start from gamma0 = 1 and repeat.
# Once the shift converges to a small value,
# we can reduce gamma0 by one order of magnitude and repeat again.
gamma0 = 10
# for a stable solution, it seems it surfices to have T/step~0.01
step = 100000
T = 300 * 2 * np.pi / omega_rf
step2 = 10000
T2 = 10 * 2 * np.pi / omega_rf

# trap parameters
aa = np.array([0.0115, -0.0125, 0.001]) # sum(aa)=0
q = np.array([0.168, -0.168, 0]) # sum(q)=0
# physical constants
const_hbar = 6.63e-34 / 2 / np.pi
const_e = 1.602e-19
const_u = 1.66e-27
const_M = 171 # Yb-171 ion
const_m = const_M * const_u
const_Coulomb = const_e**2 / 4 / np.pi / 8.85e-12
const_lambda = 369e-9 # wavelength for Doppler cooling
const_k = 2 * np.pi / const_lambda
# Doppler cooling term
alpha = 8 * const_hbar * const_k**2
# Voltages in V
V_DC = aa[2] / ((4 * const_e * 2 * 0.1153e4) / const_m / omega_rf**2)
V_AC = q[0] / ((-2 * const_e * 2 * (445.1504e4/2)) / const_m / omega_rf**2)
V_DConAC = (aa[0] - aa[1]) / 2 / ((4 * const_e * 2 * (445.1504e4/2)) / const_m
                / omega_rf**2)
# typical length scale
L0 = (const_Coulomb / const_m / omega_rf**2)**(1./3)

def gamma(t):
    #gamma_t = gamma0 * (T - t) / T
    #gamma_t = gamma0 * np.cos(np.pi/2*t/T)
    #gamma_t = gamma0 * (1 - t / T)**2
    #gamma_t = gamma0 * (1 - t / T)**3
    gamma_t = gamma0
    return(gamma_t)

#def F_DC(r):
#    # force from the fields generated by DC electrodes when 1kV is applied
#    F = np.zeros((N, 3))
##    F[:, 0] = -1e12 * (-4 * 6.4 * r[:, 0]**3 + 2 * 42.5 * r[:, 0] * r[:, 1]**2
##                - 2 * 4.1 * r[:, 0] * r[:, 2]**2) - 1e6 * (-2 * 0.43 * r[:, 0])
##    F[:, 1] = -1e12 * (-4 * 6.4 * r[:, 1]**3 + 2 * 42.5 * r[:, 0]**2 * r[:, 1]
##                - 2 * 4.1 * r[:, 1] * r[:, 2]**2) - 1e6 * (-2 * 0.43 * r[:, 1])
##    F[:, 2] = -1e12 * (4 * (16.4 / 12) * r[:, 2]**3 - 2 * 4.1 * (r[:, 0]**2
##                + r[:, 1]**2) * r[:, 2]) - 1e6 * (2 * 0.86 * r[:, 2])
#    F[:, 0] = -1e8 * (4 * 36.7984 * r[:, 0]**3 - 2 * 216.2816 * r[:, 0] * r[:, 1]**2
#                - 2 * 4.4056 * r[:, 0] * (r[:, 2]-2.1e-2)**2) - 1e4 * (-2 * 0.05767 * r[:, 0])
#    F[:, 1] = -1e8 * (4 * 36.7984 * r[:, 1]**3 - 2 * 216.2816 * r[:, 1] * r[:, 0]**2
#                - 2 * 4.4056 * r[:, 1] * (r[:, 2]-2.1e-2)**2) - 1e4 * (-2 * 0.05767 * r[:, 1])
#    F[:, 2] = -1e8 * (4 * 1.4875 * (r[:, 2]-2.1e-2)**3 - 2 * 4.4056 * (r[:, 0]**2
#                + r[:, 1]**2) * (r[:, 2]-2.1e-2)) - 1e4 * (2 * 0.1153 * (r[:, 2]-2.1e-2))
#    F = F * const_e
#    return(F)
#
#def F_AC(r):
#    # force from the fields generated by AC electrodes when 1kV is applied
#    F = np.zeros((N, 3))
##    F[:, 0] = -1e6 * (-2 * 2.23e3 * r[:, 0])
##    F[:, 1] = -1e6 * (2 * 2.23e3 * r[:, 1])
#    F[:, 0] = -1e4 * (-445.1504 * r[:, 1])
#    F[:, 1] = -1e4 * (-445.1504 * r[:, 0])
#    F = F * const_e
#    return(F)
#
#def accl_trap(r, t):
#    return((F_DC(r) * V_DC + F_AC(r) * (V_DConAC + V_AC * np.cos(omega_rf * t))
#        ) / const_m)
    
def accl_trap(r, t):
    v_ac = V_DConAC+V_AC*np.cos(omega_rf*t)
    return(np.array(MField.MField([V_DC, v_ac, 0, v_ac, 0, V_DC], r*100)) * const_e / const_m * 100) # change to cm unit

def accl(r, v, t, damped):
    # dif_ijk = r_ik - r_jk
    dif = r[:, np.newaxis, :] - r[np.newaxis, :, :]
    # dist_ij = \sqrt(\sum_k (r_ik - r_jk)^2)
    dist = np.sqrt(np.sum(dif**2, axis=2))
    # set diagonal elements to 1 for convenience of element inverse
    # it doesn't influence the calculation of acceleration
    np.fill_diagonal(dist, 1)
    a = const_Coulomb * np.sum(dif/(dist**3).reshape(N, N, 1), axis=1) \
            / const_m + accl_trap(r, t)
    if damped:
        a = a - gamma(t) * v * alpha / const_m
    return(a)

def evolve(T, step, r0, v0, damped):
    t = np.linspace(0, T, step+1)
    dt = T / step
    r = r0
    v = v0
    for i in range(step):
        k1 = accl(r, v, t[i], damped) * dt
        l1 = v * dt
        k2 = accl(r+l1/2, v+k1/2, t[i]+dt/2, damped) * dt
        l2 = (v + k1 / 2) * dt
        k3 = accl(r+l2/2, v+k2/2, t[i]+dt/2, damped) * dt
        l3 = (v + k2 / 2) * dt
        k4 = accl(r+l3, v+k3, t[i]+dt, damped) * dt
        l4 = (v + k3) * dt
        v = v + k1 / 6 + k2 / 3 + k3 / 3 + k4 / 6
        r = r + l1 / 6 + l2 / 3 + l3 / 3 + l4 / 6
    return(r, v)

def update_gamma0(s):
    try:
        return(float(s))
    except ValueError:
        return(gamma0)


r0 = (2 * np.random.rand(N, 3) - 1) * N * L0
r0[:, 2] = r0[:, 2] + 2.1e-2 # Center of the trap at z=2.1cm
v0 = np.zeros((N, 3))
while True:
    plt.close('all')
    # Run the simulation with cooling on for T
    (r, v) = evolve(T, step, r0, v0, True)
    # Turn off the cooling and evolve T2
    (r2, v2) = evolve(T2, step2, r, v, False)
    
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(r[:, 0], r[:, 1], r[:, 2])
    plt.axis('equal')
    plt.show()
    shift = np.abs(r2 - r0)
    print("Largest shift in ions' position is:", np.max(shift), '\n')
    s = input("Repeat?(y/n):")
    if s == 'n':
        break
    s = input("gamma0(current:"+str(gamma0)+")=")
    gamma0 = update_gamma0(s)
    r0 = r
    v0 = v